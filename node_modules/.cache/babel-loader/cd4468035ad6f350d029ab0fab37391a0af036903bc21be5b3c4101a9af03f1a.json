{"ast":null,"code":"var EventEmitter = require('events').EventEmitter;\nvar util = require('util');\nvar helpers = require('./helpers');\nvar Parser = require('./parser');\nvar request = require('request');\nvar STATUS_CODES_TO_ABORT_ON = require('./settings').STATUS_CODES_TO_ABORT_ON;\nvar StreamingAPIConnection = function (reqOpts, twitOptions) {\n  this.reqOpts = reqOpts;\n  this.twitOptions = twitOptions;\n  this._twitter_time_minus_local_time_ms = 0;\n  EventEmitter.call(this);\n};\nutil.inherits(StreamingAPIConnection, EventEmitter);\n\n/**\n * Resets the connection.\n * - clears request, response, parser\n * - removes scheduled reconnect handle (if one was scheduled)\n * - stops the stall abort timeout handle (if one was scheduled)\n */\nStreamingAPIConnection.prototype._resetConnection = function () {\n  if (this.request) {\n    // clear our reference to the `request` instance\n    this.request.removeAllListeners();\n    this.request.destroy();\n  }\n  if (this.response) {\n    // clear our reference to the http.IncomingMessage instance\n    this.response.removeAllListeners();\n    this.response.destroy();\n  }\n  if (this.parser) {\n    this.parser.removeAllListeners();\n  }\n\n  // ensure a scheduled reconnect does not occur (if one was scheduled)\n  // this can happen if we get a close event before .stop() is called\n  clearTimeout(this._scheduledReconnect);\n  delete this._scheduledReconnect;\n\n  // clear our stall abort timeout\n  this._stopStallAbortTimeout();\n};\n\n/**\n * Resets the parameters used in determining the next reconnect time\n */\nStreamingAPIConnection.prototype._resetRetryParams = function () {\n  // delay for next reconnection attempt\n  this._connectInterval = 0;\n  // flag indicating whether we used a 0-delay reconnect\n  this._usedFirstReconnect = false;\n};\nStreamingAPIConnection.prototype._startPersistentConnection = function () {\n  var self = this;\n  self._resetConnection();\n  self._setupParser();\n  self._resetStallAbortTimeout();\n  self._setOauthTimestamp();\n  this.reqOpts.encoding = 'utf8';\n  self.request = request.post(this.reqOpts);\n  self.emit('connect', self.request);\n  self.request.on('response', function (response) {\n    self._updateOauthTimestampOffsetFromResponse(response);\n    // reset our reconnection attempt flag so next attempt goes through with 0 delay\n    // if we get a transport-level error\n    self._usedFirstReconnect = false;\n    // start a stall abort timeout handle\n    self._resetStallAbortTimeout();\n    self.response = response;\n    if (STATUS_CODES_TO_ABORT_ON.indexOf(self.response.statusCode) !== -1) {\n      // We got a status code telling us we should abort the connection.\n      // Read the body from the response and return an error to the user.\n      var body = '';\n      self.request.on('data', function (chunk) {\n        body += chunk;\n      });\n      self.request.on('end', function () {\n        try {\n          body = JSON.parse(body);\n        } catch (jsonDecodeError) {\n          // Twitter may send an HTML body\n          // if non-JSON text was returned, we'll just attach it to the error as-is\n        }\n        // surface the error to the user\n        var error = helpers.makeTwitError('Bad Twitter streaming request: ' + self.response.statusCode);\n        error.statusCode = response ? response.statusCode : null;\n        helpers.attachBodyInfoToError(error, body);\n        self.emit('error', error);\n        // stop the stream explicitly so we don't reconnect\n        self.stop();\n        body = null;\n      });\n      self.request.on('error', function (err) {\n        var twitErr = helpers.makeTwitError(err.message);\n        twitErr.statusCode = self.response.statusCode;\n        helpers.attachBodyInfoToError(twitErr, body);\n        self.emit('parser-error', twitErr);\n      });\n    } else if (self.response.statusCode === 420) {\n      // close the connection forcibly so a reconnect is scheduled by `self.onClose()`\n      self._scheduleReconnect();\n    } else {\n      // We got an OK status code - the response should be valid.\n      // Read the body from the response and return to the user.\n      //pass all response data to parser\n      self.request.on('data', function (data) {\n        self._connectInterval = 0;\n        self._resetStallAbortTimeout();\n        self.parser.parse(data);\n      });\n      self.response.on('close', self._onClose.bind(self));\n      self.response.on('error', function (err) {\n        // expose response errors on twit instance\n        self.emit('error', err);\n      });\n\n      // connected without an error response from Twitter, emit `connected` event\n      // this must be emitted after all its event handlers are bound\n      // so the reference to `self.response` is not interfered-with by the user until it is emitted\n      self.emit('connected', self.response);\n    }\n  });\n  self.request.on('close', self._onClose.bind(self));\n  self.request.on('error', function (err) {\n    self._scheduleReconnect.bind(self);\n  });\n  return self;\n};\n\n/**\n * Handle when the request or response closes.\n * Schedule a reconnect according to Twitter's reconnect guidelines\n *\n */\nStreamingAPIConnection.prototype._onClose = function () {\n  var self = this;\n  self._stopStallAbortTimeout();\n  if (self._scheduledReconnect) {\n    // if we already have a reconnect scheduled, don't schedule another one.\n    // this race condition can happen if the http.ClientRequest and http.IncomingMessage both emit `close`\n    return;\n  }\n  self._scheduleReconnect();\n};\n\n/**\n * Kick off the http request, and persist the connection\n *\n */\nStreamingAPIConnection.prototype.start = function () {\n  this._resetRetryParams();\n  this._startPersistentConnection();\n  return this;\n};\n\n/**\n * Abort the http request, stop scheduled reconnect (if one was scheduled) and clear state\n *\n */\nStreamingAPIConnection.prototype.stop = function () {\n  // clear connection variables and timeout handles\n  this._resetConnection();\n  this._resetRetryParams();\n  return this;\n};\n\n/**\n * Stop and restart the stall abort timer (called when new data is received)\n *\n * If we go 90s without receiving data from twitter, we abort the request & reconnect.\n */\nStreamingAPIConnection.prototype._resetStallAbortTimeout = function () {\n  var self = this;\n  // stop the previous stall abort timer\n  self._stopStallAbortTimeout();\n  //start a new 90s timeout to trigger a close & reconnect if no data received\n  self._stallAbortTimeout = setTimeout(function () {\n    self._scheduleReconnect();\n  }, 90000);\n  return this;\n};\n\n/**\n * Stop stall timeout\n *\n */\nStreamingAPIConnection.prototype._stopStallAbortTimeout = function () {\n  clearTimeout(this._stallAbortTimeout);\n  // mark the timer as `null` so it is clear via introspection that the timeout is not scheduled\n  delete this._stallAbortTimeout;\n  return this;\n};\n\n/**\n * Computes the next time a reconnect should occur (based on the last HTTP response received)\n * and starts a timeout handle to begin reconnecting after `self._connectInterval` passes.\n *\n * @return {Undefined}\n */\nStreamingAPIConnection.prototype._scheduleReconnect = function () {\n  var self = this;\n  if (self.response && self.response.statusCode === 420) {\n    // we are being rate limited\n    // start with a 1 minute wait and double each attempt\n    if (!self._connectInterval) {\n      self._connectInterval = 60000;\n    } else {\n      self._connectInterval *= 2;\n    }\n  } else if (self.response && String(self.response.statusCode).charAt(0) === '5') {\n    // twitter 5xx errors\n    // start with a 5s wait, double each attempt up to 320s\n    if (!self._connectInterval) {\n      self._connectInterval = 5000;\n    } else if (self._connectInterval < 320000) {\n      self._connectInterval *= 2;\n    } else {\n      self._connectInterval = 320000;\n    }\n  } else {\n    // we did not get an HTTP response from our last connection attempt.\n    // DNS/TCP error, or a stall in the stream (and stall timer closed the connection)\n    if (!self._usedFirstReconnect) {\n      // first reconnection attempt on a valid connection should occur immediately\n      self._connectInterval = 0;\n      self._usedFirstReconnect = true;\n    } else if (self._connectInterval < 16000) {\n      // linearly increase delay by 250ms up to 16s\n      self._connectInterval += 250;\n    } else {\n      // cap out reconnect interval at 16s\n      self._connectInterval = 16000;\n    }\n  }\n\n  // schedule the reconnect\n  self._scheduledReconnect = setTimeout(function () {\n    self._startPersistentConnection();\n  }, self._connectInterval);\n  self.emit('reconnect', self.request, self.response, self._connectInterval);\n};\nStreamingAPIConnection.prototype._setupParser = function () {\n  var self = this;\n  self.parser = new Parser();\n\n  // handle twitter objects as they come in - emit the generic `message` event\n  // along with the specific event corresponding to the message\n  self.parser.on('element', function (msg) {\n    self.emit('message', msg);\n    if (msg.delete) {\n      self.emit('delete', msg);\n    } else if (msg.disconnect) {\n      self._handleDisconnect(msg);\n    } else if (msg.limit) {\n      self.emit('limit', msg);\n    } else if (msg.scrub_geo) {\n      self.emit('scrub_geo', msg);\n    } else if (msg.warning) {\n      self.emit('warning', msg);\n    } else if (msg.status_withheld) {\n      self.emit('status_withheld', msg);\n    } else if (msg.user_withheld) {\n      self.emit('user_withheld', msg);\n    } else if (msg.friends || msg.friends_str) {\n      self.emit('friends', msg);\n    } else if (msg.direct_message) {\n      self.emit('direct_message', msg);\n    } else if (msg.event) {\n      self.emit('user_event', msg);\n      // reference: https://dev.twitter.com/docs/streaming-apis/messages#User_stream_messages\n      var ev = msg.event;\n      if (ev === 'blocked') {\n        self.emit('blocked', msg);\n      } else if (ev === 'unblocked') {\n        self.emit('unblocked', msg);\n      } else if (ev === 'favorite') {\n        self.emit('favorite', msg);\n      } else if (ev === 'unfavorite') {\n        self.emit('unfavorite', msg);\n      } else if (ev === 'follow') {\n        self.emit('follow', msg);\n      } else if (ev === 'unfollow') {\n        self.emit('unfollow', msg);\n      } else if (ev === 'mute') {\n        self.emit('mute', msg);\n      } else if (ev === 'unmute') {\n        self.emit('unmute', msg);\n      } else if (ev === 'user_update') {\n        self.emit('user_update', msg);\n      } else if (ev === 'list_created') {\n        self.emit('list_created', msg);\n      } else if (ev === 'list_destroyed') {\n        self.emit('list_destroyed', msg);\n      } else if (ev === 'list_updated') {\n        self.emit('list_updated', msg);\n      } else if (ev === 'list_member_added') {\n        self.emit('list_member_added', msg);\n      } else if (ev === 'list_member_removed') {\n        self.emit('list_member_removed', msg);\n      } else if (ev === 'list_user_subscribed') {\n        self.emit('list_user_subscribed', msg);\n      } else if (ev === 'list_user_unsubscribed') {\n        self.emit('list_user_unsubscribed', msg);\n      } else if (ev === 'quoted_tweet') {\n        self.emit('quoted_tweet', msg);\n      } else if (ev === 'favorited_retweet') {\n        self.emit('favorited_retweet', msg);\n      } else if (ev === 'retweeted_retweet') {\n        self.emit('retweeted_retweet', msg);\n      } else {\n        self.emit('unknown_user_event', msg);\n      }\n    } else {\n      self.emit('tweet', msg);\n    }\n  });\n  self.parser.on('error', function (err) {\n    self.emit('parser-error', err);\n  });\n  self.parser.on('connection-limit-exceeded', function (err) {\n    self.emit('error', err);\n  });\n};\nStreamingAPIConnection.prototype._handleDisconnect = function (twitterMsg) {\n  this.emit('disconnect', twitterMsg);\n  this.stop();\n};\n\n/**\n * Call whenever an http request is about to be made to update\n * our local timestamp (used for Oauth) to be Twitter's server time.\n *\n */\nStreamingAPIConnection.prototype._setOauthTimestamp = function () {\n  var self = this;\n  if (self.reqOpts.oauth) {\n    var oauth_ts = Date.now() + self._twitter_time_minus_local_time_ms;\n    self.reqOpts.oauth.timestamp = Math.floor(oauth_ts / 1000).toString();\n  }\n};\n\n/**\n * Call whenever an http response is received from Twitter,\n * to set our local timestamp offset from Twitter's server time.\n * This is used to set the Oauth timestamp for our next http request\n * to Twitter (by calling _setOauthTimestamp).\n *\n * @param  {http.IncomingResponse} resp   http response received from Twitter.\n */\nStreamingAPIConnection.prototype._updateOauthTimestampOffsetFromResponse = function (resp) {\n  if (resp && resp.headers && resp.headers.date && new Date(resp.headers.date).toString() !== 'Invalid Date') {\n    var twitterTimeMs = new Date(resp.headers.date).getTime();\n    this._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n  }\n};\nmodule.exports = StreamingAPIConnection;","map":{"version":3,"names":["EventEmitter","require","util","helpers","Parser","request","STATUS_CODES_TO_ABORT_ON","StreamingAPIConnection","reqOpts","twitOptions","_twitter_time_minus_local_time_ms","call","inherits","prototype","_resetConnection","removeAllListeners","destroy","response","parser","clearTimeout","_scheduledReconnect","_stopStallAbortTimeout","_resetRetryParams","_connectInterval","_usedFirstReconnect","_startPersistentConnection","self","_setupParser","_resetStallAbortTimeout","_setOauthTimestamp","encoding","post","emit","on","_updateOauthTimestampOffsetFromResponse","indexOf","statusCode","body","chunk","JSON","parse","jsonDecodeError","error","makeTwitError","attachBodyInfoToError","stop","err","twitErr","message","_scheduleReconnect","data","_onClose","bind","start","_stallAbortTimeout","setTimeout","String","charAt","msg","delete","disconnect","_handleDisconnect","limit","scrub_geo","warning","status_withheld","user_withheld","friends","friends_str","direct_message","event","ev","twitterMsg","oauth","oauth_ts","Date","now","timestamp","Math","floor","toString","resp","headers","date","twitterTimeMs","getTime","module","exports"],"sources":["C:/Users/Sanity/Documents/GitHub/animalbrowsing/node_modules/twit/lib/streaming-api-connection.js"],"sourcesContent":["\nvar EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\nvar helpers = require('./helpers')\nvar Parser = require('./parser');\nvar request = require('request');\n\nvar STATUS_CODES_TO_ABORT_ON = require('./settings').STATUS_CODES_TO_ABORT_ON\n\nvar StreamingAPIConnection = function (reqOpts, twitOptions) {\n  this.reqOpts = reqOpts\n  this.twitOptions = twitOptions\n  this._twitter_time_minus_local_time_ms = 0\n  EventEmitter.call(this)\n}\n\nutil.inherits(StreamingAPIConnection, EventEmitter)\n\n/**\n * Resets the connection.\n * - clears request, response, parser\n * - removes scheduled reconnect handle (if one was scheduled)\n * - stops the stall abort timeout handle (if one was scheduled)\n */\nStreamingAPIConnection.prototype._resetConnection = function () {\n  if (this.request) {\n    // clear our reference to the `request` instance\n    this.request.removeAllListeners();\n    this.request.destroy();\n  }\n\n  if (this.response) {\n    // clear our reference to the http.IncomingMessage instance\n    this.response.removeAllListeners();\n    this.response.destroy();\n  }\n\n  if (this.parser) {\n    this.parser.removeAllListeners()\n  }\n\n  // ensure a scheduled reconnect does not occur (if one was scheduled)\n  // this can happen if we get a close event before .stop() is called\n  clearTimeout(this._scheduledReconnect)\n  delete this._scheduledReconnect\n\n  // clear our stall abort timeout\n  this._stopStallAbortTimeout()\n}\n\n/**\n * Resets the parameters used in determining the next reconnect time\n */\nStreamingAPIConnection.prototype._resetRetryParams = function () {\n  // delay for next reconnection attempt\n  this._connectInterval = 0\n  // flag indicating whether we used a 0-delay reconnect\n  this._usedFirstReconnect = false\n}\n\nStreamingAPIConnection.prototype._startPersistentConnection = function () {\n  var self = this;\n  self._resetConnection();\n  self._setupParser();\n  self._resetStallAbortTimeout();\n  self._setOauthTimestamp();\n  this.reqOpts.encoding = 'utf8'\n  self.request = request.post(this.reqOpts);\n  self.emit('connect', self.request);\n  self.request.on('response', function (response) {\n    self._updateOauthTimestampOffsetFromResponse(response)\n    // reset our reconnection attempt flag so next attempt goes through with 0 delay\n    // if we get a transport-level error\n    self._usedFirstReconnect = false;\n    // start a stall abort timeout handle\n    self._resetStallAbortTimeout();\n    self.response = response\n    if (STATUS_CODES_TO_ABORT_ON.indexOf(self.response.statusCode) !== -1) {\n      // We got a status code telling us we should abort the connection.\n      // Read the body from the response and return an error to the user.\n      var body = '';\n\n      self.request.on('data', function (chunk) {\n        body += chunk;\n      })\n\n      self.request.on('end', function () {\n        try {\n          body = JSON.parse(body)\n        } catch (jsonDecodeError) {\n          // Twitter may send an HTML body\n          // if non-JSON text was returned, we'll just attach it to the error as-is\n        }\n        // surface the error to the user\n        var error = helpers.makeTwitError('Bad Twitter streaming request: ' + self.response.statusCode)\n        error.statusCode = response ? response.statusCode: null;\n        helpers.attachBodyInfoToError(error, body)\n        self.emit('error', error);\n        // stop the stream explicitly so we don't reconnect\n        self.stop()\n        body = null;\n      });\n      self.request.on('error', function (err) {\n        var twitErr = helpers.makeTwitError(err.message);\n        twitErr.statusCode = self.response.statusCode;\n        helpers.attachBodyInfoToError(twitErr, body);\n        self.emit('parser-error', twitErr);\n      });\n    } else if (self.response.statusCode === 420) {\n      // close the connection forcibly so a reconnect is scheduled by `self.onClose()`\n      self._scheduleReconnect();\n    } else {\n      // We got an OK status code - the response should be valid.\n      // Read the body from the response and return to the user.\n      //pass all response data to parser\n      self.request.on('data', function(data) {\n        self._connectInterval = 0\n        self._resetStallAbortTimeout();\n        self.parser.parse(data);\n      })\n\n      self.response.on('close', self._onClose.bind(self))\n      self.response.on('error', function (err) {\n        // expose response errors on twit instance\n        self.emit('error', err);\n      })\n\n      // connected without an error response from Twitter, emit `connected` event\n      // this must be emitted after all its event handlers are bound\n      // so the reference to `self.response` is not interfered-with by the user until it is emitted\n      self.emit('connected', self.response);\n    }\n  });\n  self.request.on('close', self._onClose.bind(self));\n  self.request.on('error', function (err) { self._scheduleReconnect.bind(self) });\n  return self;\n}\n\n/**\n * Handle when the request or response closes.\n * Schedule a reconnect according to Twitter's reconnect guidelines\n *\n */\nStreamingAPIConnection.prototype._onClose = function () {\n  var self = this;\n  self._stopStallAbortTimeout();\n  if (self._scheduledReconnect) {\n    // if we already have a reconnect scheduled, don't schedule another one.\n    // this race condition can happen if the http.ClientRequest and http.IncomingMessage both emit `close`\n    return\n  }\n\n  self._scheduleReconnect();\n}\n\n/**\n * Kick off the http request, and persist the connection\n *\n */\nStreamingAPIConnection.prototype.start = function () {\n  this._resetRetryParams();\n  this._startPersistentConnection();\n  return this;\n}\n\n/**\n * Abort the http request, stop scheduled reconnect (if one was scheduled) and clear state\n *\n */\nStreamingAPIConnection.prototype.stop = function () {\n  // clear connection variables and timeout handles\n  this._resetConnection();\n  this._resetRetryParams();\n  return this;\n}\n\n/**\n * Stop and restart the stall abort timer (called when new data is received)\n *\n * If we go 90s without receiving data from twitter, we abort the request & reconnect.\n */\nStreamingAPIConnection.prototype._resetStallAbortTimeout = function () {\n  var self = this;\n  // stop the previous stall abort timer\n  self._stopStallAbortTimeout();\n  //start a new 90s timeout to trigger a close & reconnect if no data received\n  self._stallAbortTimeout = setTimeout(function () {\n    self._scheduleReconnect()\n  }, 90000);\n  return this;\n}\n\n/**\n * Stop stall timeout\n *\n */\nStreamingAPIConnection.prototype._stopStallAbortTimeout = function () {\n  clearTimeout(this._stallAbortTimeout);\n  // mark the timer as `null` so it is clear via introspection that the timeout is not scheduled\n  delete this._stallAbortTimeout;\n  return this;\n}\n\n/**\n * Computes the next time a reconnect should occur (based on the last HTTP response received)\n * and starts a timeout handle to begin reconnecting after `self._connectInterval` passes.\n *\n * @return {Undefined}\n */\nStreamingAPIConnection.prototype._scheduleReconnect = function () {\n  var self = this;\n  if (self.response && self.response.statusCode === 420) {\n    // we are being rate limited\n    // start with a 1 minute wait and double each attempt\n    if (!self._connectInterval) {\n      self._connectInterval = 60000;\n    } else {\n      self._connectInterval *= 2;\n    }\n  } else if (self.response && String(self.response.statusCode).charAt(0) === '5') {\n    // twitter 5xx errors\n    // start with a 5s wait, double each attempt up to 320s\n    if (!self._connectInterval) {\n      self._connectInterval = 5000;\n    } else if (self._connectInterval < 320000) {\n      self._connectInterval *= 2;\n    } else {\n      self._connectInterval = 320000;\n    }\n  } else {\n    // we did not get an HTTP response from our last connection attempt.\n    // DNS/TCP error, or a stall in the stream (and stall timer closed the connection)\n    if (!self._usedFirstReconnect) {\n      // first reconnection attempt on a valid connection should occur immediately\n      self._connectInterval = 0;\n      self._usedFirstReconnect = true;\n    } else if (self._connectInterval < 16000) {\n      // linearly increase delay by 250ms up to 16s\n      self._connectInterval += 250;\n    } else {\n      // cap out reconnect interval at 16s\n      self._connectInterval = 16000;\n    }\n  }\n\n  // schedule the reconnect\n  self._scheduledReconnect = setTimeout(function () {\n    self._startPersistentConnection();\n  }, self._connectInterval);\n  self.emit('reconnect', self.request, self.response, self._connectInterval);\n}\n\nStreamingAPIConnection.prototype._setupParser = function () {\n  var self = this\n  self.parser = new Parser()\n\n  // handle twitter objects as they come in - emit the generic `message` event\n  // along with the specific event corresponding to the message\n  self.parser.on('element', function (msg) {\n    self.emit('message', msg)\n\n    if      (msg.delete)          { self.emit('delete', msg) }\n    else if (msg.disconnect)      { self._handleDisconnect(msg) }\n    else if (msg.limit)           { self.emit('limit', msg) }\n    else if (msg.scrub_geo)       { self.emit('scrub_geo', msg) }\n    else if (msg.warning)         { self.emit('warning', msg) }\n    else if (msg.status_withheld) { self.emit('status_withheld', msg) }\n    else if (msg.user_withheld)   { self.emit('user_withheld', msg) }\n    else if (msg.friends || msg.friends_str) { self.emit('friends', msg) }\n    else if (msg.direct_message)  { self.emit('direct_message', msg) }\n    else if (msg.event)           {\n      self.emit('user_event', msg)\n      // reference: https://dev.twitter.com/docs/streaming-apis/messages#User_stream_messages\n      var ev = msg.event\n\n      if      (ev === 'blocked')                { self.emit('blocked', msg) }\n      else if (ev === 'unblocked')              { self.emit('unblocked', msg) }\n      else if (ev === 'favorite')               { self.emit('favorite', msg) }\n      else if (ev === 'unfavorite')             { self.emit('unfavorite', msg) }\n      else if (ev === 'follow')                 { self.emit('follow', msg) }\n      else if (ev === 'unfollow')               { self.emit('unfollow', msg) }\n      else if (ev === 'mute')                   { self.emit('mute', msg) }\n      else if (ev === 'unmute')                 { self.emit('unmute', msg) }\n      else if (ev === 'user_update')            { self.emit('user_update', msg) }\n      else if (ev === 'list_created')           { self.emit('list_created', msg) }\n      else if (ev === 'list_destroyed')         { self.emit('list_destroyed', msg) }\n      else if (ev === 'list_updated')           { self.emit('list_updated', msg) }\n      else if (ev === 'list_member_added')      { self.emit('list_member_added', msg) }\n      else if (ev === 'list_member_removed')    { self.emit('list_member_removed', msg) }\n      else if (ev === 'list_user_subscribed')   { self.emit('list_user_subscribed', msg) }\n      else if (ev === 'list_user_unsubscribed') { self.emit('list_user_unsubscribed', msg) }\n      else if (ev === 'quoted_tweet')           { self.emit('quoted_tweet', msg) }\n      else if (ev === 'favorited_retweet')      { self.emit('favorited_retweet', msg) }\n      else if (ev === 'retweeted_retweet')      { self.emit('retweeted_retweet', msg) }\n      else                                      { self.emit('unknown_user_event', msg) }\n    } else                                      { self.emit('tweet', msg) }\n  })\n\n  self.parser.on('error', function (err) {\n    self.emit('parser-error', err)\n  });\n  self.parser.on('connection-limit-exceeded', function (err) {\n    self.emit('error', err);\n  })\n}\n\nStreamingAPIConnection.prototype._handleDisconnect = function (twitterMsg) {\n  this.emit('disconnect', twitterMsg);\n  this.stop();\n}\n\n/**\n * Call whenever an http request is about to be made to update\n * our local timestamp (used for Oauth) to be Twitter's server time.\n *\n */\nStreamingAPIConnection.prototype._setOauthTimestamp = function () {\n  var self = this;\n  if (self.reqOpts.oauth) {\n    var oauth_ts = Date.now() + self._twitter_time_minus_local_time_ms;\n    self.reqOpts.oauth.timestamp = Math.floor(oauth_ts/1000).toString();\n  }\n}\n\n/**\n * Call whenever an http response is received from Twitter,\n * to set our local timestamp offset from Twitter's server time.\n * This is used to set the Oauth timestamp for our next http request\n * to Twitter (by calling _setOauthTimestamp).\n *\n * @param  {http.IncomingResponse} resp   http response received from Twitter.\n */\nStreamingAPIConnection.prototype._updateOauthTimestampOffsetFromResponse = function (resp) {\n  if (resp && resp.headers && resp.headers.date &&\n      new Date(resp.headers.date).toString() !== 'Invalid Date'\n  ) {\n    var twitterTimeMs = new Date(resp.headers.date).getTime()\n    this._twitter_time_minus_local_time_ms = twitterTimeMs - Date.now();\n  }\n}\n\nmodule.exports = StreamingAPIConnection\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}